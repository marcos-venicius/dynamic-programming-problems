#!/usr/bin/env python3

from time import time

# 1 -> 1 -> 2 -> 3 -> 5 -> 8 -> 13
def fib(n):
    n1 = 1
    n2 = 1

    for _ in range(n - 1):
        tmpN1 = n1
        n1 = n2
        n2 = tmpN1 + n2

    return n1


# improve this
# from:
# def fibRecursive(n):
#     if n <= 2:
#         return 1
# 
#     return fibRecursive(n - 1) + fibRecursive(n - 2)
#
# TO:
def fibRecursive(n, memo = {}):
    # check if has the result to the current value on memo map
    # if have, just return it
    if n in memo:
        return memo[n]

    if n <= 2:
        return 1

    # if not have in memo
    # calculate the two args (n - 1), (n - 2)...
    n1 = fibRecursive(n - 1)
    n2 = fibRecursive(n - 2)

    # ...and add to the memo map
    memo[n - 1] = n1
    memo[n - 2] = n2

    # return the value
    return n1 + n2

# keep memo values between all tests
class Fib:
    def __init__(self):
        self.memo = {}

    def calc(self, n):
        if n in self.memo:
            return self.memo[n]

        if n <= 2:
            return 1

        # if not have in memo
        # calculate the two args (n - 1), (n - 2)...
        n1 = self.calc(n - 1)
        n2 = self.calc(n - 2)

        # ...and add to the memo map
        self.memo[n] = n1 + n2
        self.memo[n - 1] = n1
        self.memo[n - 2] = n2

        # return the value
        return self.memo[n]

tests = [
    (1, 1),
    (2, 1),
    (3, 2),
    (4, 3),
    (5, 5),
    (6, 8),
    (7, 13),
    (8, 21),
    (9, 34),
    (10, 55),
    (11, 89),
    (12, 144),
    (13, 233),
    (14, 377),
    (15, 610),
    (16, 987),
    (17, 1597),
    (18, 2584),
    (19, 4181),
    (20, 6765),
    (21, 10946),
    (22, 17711),
    (23, 28657),
    (24, 46368),
    (25, 75025),
    (26, 121393),
    (27, 196418),
    (28, 317811),
    (29, 514229),
    (30, 832040),
    (31, 1346269),
    (32, 2178309),
    (33, 3524578),
    (34, 5702887),
    (35, 9227465),
    (36, 14930352),
    (37, 24157817),
    (38, 39088169),
    (39, 63245986),
    (40, 102334155),
    (41, 165580141),
    (42, 267914296),
    (43, 433494437),
    (44, 701408733),
    (45, 1134903170),
    (46, 1836311903),
    (47, 2971215073),
    (48, 4807526976),
    (49, 7778742049),
    (50, 12586269025),
    (51, 20365011074),
    (52, 32951280099),
    (53, 53316291173),
    (54, 86267571272),
    (55, 139583862445),
    (56, 225851433717),
    (57, 365435296162),
    (58, 591286729879),
    (59, 956722026041),
    (60, 1548008755920),
    (61, 2504730781961),
    (62, 4052739537881),
    (63, 6557470319842),
    (64, 10610209857723),
    (65, 17167680177565),
    (66, 27777890035288),
    (67, 44945570212853),
    (68, 72723460248141),
    (69, 117669030460994),
    (70, 190392490709135),
    (71, 308061521170129),
    (72, 498454011879264),
    (73, 806515533049393),
    (74, 1304969544928657),
    (75, 2111485077978050),
    (76, 3416454622906707),
    (77, 5527939700884757),
    (78, 8944394323791464),
    (79, 14472334024676221),
    (80, 23416728348467685),
    (81, 37889062373143906),
    (82, 61305790721611591),
    (83, 99194853094755497),
    (84, 160500643816367088),
    (85, 259695496911122585),
    (86, 420196140727489673),
    (87, 679891637638612258),
    (88, 1100087778366101931),
    (89, 1779979416004714189),
    (90, 2880067194370816120),
    (91, 4660046610375530309),
    (92, 7540113804746346429),
    (93, 12200160415121876738),
    (94, 19740274219868223167),
    (95, 31940434634990099905),
    (96, 51680708854858323072),
    (97, 83621143489848422977),
    (98, 135301852344706746049),
    (99, 218922995834555169026),
    (100, 354224848179261915075),
    (101, 573147844013817084101),
    (102, 927372692193078999176),
    (103, 1500520536206896083277),
    (104, 2427893228399975082453),
    (105, 3928413764606871165730),
    (106, 6356306993006846248183),
    (107, 10284720757613717413913),
    (108, 16641027750620563662096),
    (109, 26925748508234281076009),
    (110, 43566776258854844738105),
    (111, 70492524767089125814114),
    (112, 114059301025943970552219),
    (113, 184551825793033096366333),
    (114, 298611126818977066918552),
    (115, 483162952612010163284885),
    (116, 781774079430987230203437),
    (117, 1264937032042997393488322),
    (118, 2046711111473984623691759),
    (119, 3311648143516982017180081),
    (120, 5358359254990966640871840),
    (121, 8670007398507948658051921),
    (122, 14028366653498915298923761),
    (123, 22698374052006863956975682),
    (124, 36726740705505779255899443),
    (125, 59425114757512643212875125),
    (126, 96151855463018422468774568),
    (127, 155576970220531065681649693),
    (128, 251728825683549488150424261),
    (129, 407305795904080553832073954),
    (130, 659034621587630041982498215),
    (131, 1066340417491710595814572169),
    (132, 1725375039079340637797070384),
    (133, 2791715456571051233611642553),
    (134, 4517090495650391871408712937),
    (135, 7308805952221443105020355490),
    (136, 11825896447871834976429068427),
    (137, 19134702400093278081449423917),
    (138, 30960598847965113057878492344),
    (139, 50095301248058391139327916261),
    (140, 81055900096023504197206408605),
    (141, 131151201344081895336534324866),
    (142, 212207101440105399533740733471),
    (143, 343358302784187294870275058337),
    (144, 555565404224292694404015791808),
    (145, 898923707008479989274290850145),
    (146, 1454489111232772683678306641953),
    (147, 2353412818241252672952597492098),
    (148, 3807901929474025356630904134051),
    (149, 6161314747715278029583501626149),
    (150, 9969216677189303386214405760200)
]

def test1():
    print("using for loop: ")
    start = time()

    for test in tests:
        r = fib(test[0])
        assert r == test[1], f"num: {test[0]} should be equal to {test[1]} (!= {r})"

    end = time()

    r = end - start
    print(f"{r:.5f}s")

def test2():
    print("using recursion: ")
    start = time()

    for test in tests:
        r = fibRecursive(test[0])
        assert r == test[1], f"num: {test[0]} should be equal to {test[1]} (!= {r})"

    end = time()

    r = end - start
    print(f"{r:.5f}s")

def test3():
    print("using Fib class: ")
    f = Fib()

    start = time()

    for test in tests:
        r = f.calc(test[0])
        assert r == test[1], f"num: {test[0]} should be equal to {test[1]} (!= {r})"

    end = time()

    r = end - start
    print(f'{len(f.memo.keys())} values memoized')
    print(f"{r:.5f}s")

test1()
print()
test2()
print()
test3()

# when you will calculate so much fibonacci numbers like this, the Fib class will be more performatic
# because after some time, this will have so many values pre-calculate and will not need to calculate again
